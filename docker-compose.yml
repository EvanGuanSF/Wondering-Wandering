version: '2'
services:
  # Our Node.js with Express webapp.
  app:
    container_name: wondering-wandering-container
    hostname: app
    restart: always
    build:
      context: ./app
      dockerfile: Dockerfile
    mem_limit: 500m
    # Do not expose ports; we rely on nginx to proxy traffic to
    # this container from within the container network.
    # ports:
    depends_on:
      - redis-server
    volumes:
      # Map our spp folder in to the container's app folder.
      - ./app:/usr/src/app
      - /app/node_modules
    networks:
      - wondering-wandering
    command: >
      /bin/bash -c "
      npm install -g node-gyp
      && npm install
      && npm start"

  # Our Nginx reverse proxy.
  nginx:
    container_name: nginx-container
    image: nginx
    hostname: nginx
    build:
      context: ./nginx
      dockerfile: Dockerfile
    mem_limit: 200m
    ports:
      - '80:80'
      - '443:443'
    # Wait for the app to finish starting up before setting up the proxy.
    depends_on:
      - app
    # Nginx does not support .env environment variable substituation by default,
    # so we must generate our own .conf files.
    environment:
      # For these variables, see the ./.env file for more details.
      - NGINX_HOSTS_OR_IP_ADDRESSES=${NGINX_HOSTS_OR_IP_ADDRESSES}
      - NGINX_HTTP_PORT=${NGINX_HTTP_PORT}
      - NGINX_HTTPS_PORT=${NGINX_HTTPS_PORT}
      - NGINX_WEBROOT_PATH=${NGINX_WEBROOT_PATH}
      - NGINX_SSL_PARAMS_SNIPPET_PATH=${NGINX_SSL_PARAMS_SNIPPET_PATH}
      - NGINX_SSL_DHPARAM_PATH=${NGINX_SSL_DHPARAM_PATH}
      - CERTBOT_CERTIFICATES_PATH=${CERTBOT_CERTIFICATES_PATH}
      - CERTBOT_YOUR_SITE_DOMAIN=${CERTBOT_YOUR_SITE_DOMAIN}
      # Note that we need to do some trickery to replace '$' literals in the .conf files.
      # If you need to use a literal '$' in one of the upcoming files,
      # you must replace it with ${DOLLAR}
      # Note also that docker-compose treats '$' as a special character,
      # so it must be escaped via '$$'.
      - DOLLAR=$$
      # For development or using your own certificates, use the commented-out lines in 
      # ./nginx/conf.d/snippets/ssl-params.conf_template
      - NGINX_SSL_CERTIFICATE_PATH=${NGINX_SSL_CERTIFICATE_PATH}
      - NGINX_SSL_KEY_PATH=${NGINX_SSL_KEY_PATH}
      # Copy our existing certificates to the 
      # envsubst will generate proper .conf files for us from the templates and the .env file.
      # Then, we start up nginx.
      # Finally, we start a loop to check for renewed ssl cert+key every 12 hours.
    command: > 
      /bin/bash -c "
      mkdir -p /${CERTBOT_CERTIFICATES_PATH}
      && chmod 777 /tmp/fullchain.pem /tmp/privkey.pem
      && mv /tmp/fullchain.pem /tmp/privkey.pem ${CERTBOT_CERTIFICATES_PATH}
      && envsubst < /etc/nginx/conf.d/nginxconf.conf_template >| /etc/nginx/conf.d/nginx.conf
      && envsubst < /etc/nginx/conf.d/snippets/ssl-params.conf_template >| /etc/nginx/conf.d/snippets/ssl-params.conf
      && nginx -t
      && exec nginx -g 'daemon off;'"
    volumes:
      # Map our conf files to the nginx configurations folder.
      - ./nginx/conf:/etc/nginx/conf.d
      # The following will allow nginx to answer certbot authentication challenges.
      - web-root:${NGINX_WEBROOT_PATH} 
      - certbot-certs:${CERTBOT_CERTIFICATES_PATH}
    networks:
      - wondering-wandering

  # Our memcache redis server.
  redis-server:
    container_name: redis-server-container
    image: redis
    hostname: redis-server
    build:
      context: ./redis-server
      dockerfile: Dockerfile
    mem_limit: 200m
    networks:
      - wondering-wandering

  # Our Certbot container.
  certbot:
    container_name: certbot-container
    image: certbot/certbot
    build:
      context: ./certbot
    mem_limit: 100m
    # Have this container listen to port 6379 internally.
    volumes:
      # The following will allow for nginx to pass on certbot authentication challenges.
      - web-root:${NGINX_WEBROOT_PATH}
      - certbot-certs:${CERTBOT_CERTIFICATES_PATH}/${CERTBOT_YOUR_SITE_DOMAIN}
      - ./ssl_creds:/ssl_creds
    depends_on:
      - nginx
    # This command gets a certificate for the site when the container is started.
    # Remove the dummy certificates we started with and then
    # create a new set of certificate and key. (If valid certbot certs exist, keep them.)
    command: certonly --webroot --webroot-path=${NGINX_WEBROOT_PATH} --email ${CERTBOT_REGISTRATION_EMAIL} --agree-tos --no-eff-email -d ${CERTBOT_YOUR_SITE_DOMAIN}
    # Trap certbot's default exit call so the container does not automatically exit.
    # Then copy the keys generated (if any) to the externally bound folder.
    # Then the while loop keeps the container from closing,
    # allowing crontab to run in the background and update certificates for us via certbot renew.
    entrypoint: "/bin/sh -c 'trap exit TERM; cp -R ${CERTBOT_CERTIFICATES_PATH}/${CERTBOT_YOUR_SITE_DOMAIN}/* /ssl_creds; while :; do echo $$(date -u): certbot: zzz...; sleep 5s & wait $${!}; done'"
    networks:
      - wondering-wandering

volumes:
  certbot-certs:
  web-root:
    driver: local
    driver_opts:
      type: none
      device: ${MAIN_FOLDER_PATH}
      o: bind

# Create a network so that these containers can talk to each other.
networks:
  wondering-wandering:
    driver: bridge
